//
//  M2Services.m
//  M2
//

#import "M2Services.h"

#import <AVFoundation/AVFoundation.h>
#import <CoreImage/CoreImage.h>
#import <math.h>
#import <MediaPlayer/MediaPlayer.h>
#import <objc/message.h>

#import "AppDelegate.h"

NSString * const M2PlaybackStateDidChangeNotification = @"M2PlaybackStateDidChangeNotification";
NSString * const M2PlaybackProgressDidChangeNotification = @"M2PlaybackProgressDidChangeNotification";
NSString * const M2PlaylistsDidChangeNotification = @"M2PlaylistsDidChangeNotification";
NSString * const M2FavoritesDidChangeNotification = @"M2FavoritesDidChangeNotification";
NSString * const M2SleepTimerDidChangeNotification = @"M2SleepTimerDidChangeNotification";

static NSString * const kMusicFolderName = @"M2";
static NSString * const kPlaylistsDefaultsKey = @"m2_playlists_v2";
static NSString * const kFavoritesDefaultsKey = @"m2_favorites_v1";
static NSString * const kPlaylistCoverFolderName = @"PlaylistCovers";
static NSString * const kPlaylistsBackupFileName = @"m2_playlists_backup_v1.json";
static NSString * const kTrackAnalyticsEntityName = @"TrackAnalytics";
static NSString * const kTrackAnalyticsTrackIDKey = @"trackID";
static NSString * const kTrackAnalyticsPlayCountKey = @"playCount";
static NSString * const kTrackAnalyticsSkipCountKey = @"skipCount";
static NSString * const kTrackAnalyticsUpdatedAtKey = @"updatedAt";

static NSArray<NSString *> *M2LegacyPlaylistsDefaultsKeys(void) {
    return @[@"m2_playlists_v1", @"m2_playlists"];
}

static void M2SyncSleepLiveActivity(NSTimeInterval remainingSeconds) {
    if (!isfinite(remainingSeconds) || remainingSeconds <= 0.0) {
        return;
    }

    Class bridgeClass = NSClassFromString(@"M2SleepLiveActivityBridge");
    if (bridgeClass == Nil) {
        return;
    }

    SEL selector = NSSelectorFromString(@"syncSleepTimerWithRemaining:title:subtitle:");
    if (![bridgeClass respondsToSelector:selector]) {
        return;
    }

    M2Track *track = M2PlaybackManager.sharedManager.currentTrack;
    NSString *title = track.title.length > 0 ? track.title : @"Sleep Timer";
    NSString *subtitle = track.artist.length > 0 ? track.artist : @"";

    void (*function)(id, SEL, NSTimeInterval, NSString *, NSString *) = (void *)[bridgeClass methodForSelector:selector];
    if (function != NULL) {
        function(bridgeClass, selector, remainingSeconds, title, subtitle);
    }
}

static void M2EndSleepLiveActivity(void) {
    Class bridgeClass = NSClassFromString(@"M2SleepLiveActivityBridge");
    if (bridgeClass == Nil) {
        return;
    }

    SEL selector = NSSelectorFromString(@"endSleepTimerActivity");
    if (![bridgeClass respondsToSelector:selector]) {
        return;
    }

    void (*function)(id, SEL) = (void *)[bridgeClass methodForSelector:selector];
    if (function != NULL) {
        function(bridgeClass, selector);
    }
}

#pragma mark - Artwork Accent

static UIColor *M2AverageColorFromImage(UIImage *image) {
    if (image == nil || image.CGImage == nil) {
        return nil;
    }

    CIImage *inputImage = [[CIImage alloc] initWithCGImage:image.CGImage];
    if (inputImage == nil) {
        return nil;
    }

    CIFilter *filter = [CIFilter filterWithName:@"CIAreaAverage"];
    if (filter == nil) {
        return nil;
    }
    [filter setValue:inputImage forKey:kCIInputImageKey];
    [filter setValue:[CIVector vectorWithCGRect:inputImage.extent] forKey:kCIInputExtentKey];

    CIImage *outputImage = filter.outputImage;
    if (outputImage == nil) {
        return nil;
    }

    static CIContext *context = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        context = [CIContext contextWithOptions:@{
            kCIContextUseSoftwareRenderer: @NO
        }];
    });

    uint8_t rgba[4] = {0, 0, 0, 0};
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    if (colorSpace == nil) {
        return nil;
    }

    [context render:outputImage
           toBitmap:rgba
           rowBytes:4
             bounds:CGRectMake(0.0, 0.0, 1.0, 1.0)
             format:kCIFormatRGBA8
         colorSpace:colorSpace];
    CGColorSpaceRelease(colorSpace);

    CGFloat alpha = ((CGFloat)rgba[3]) / 255.0;
    if (alpha <= 0.02) {
        return nil;
    }

    return [UIColor colorWithRed:((CGFloat)rgba[0]) / 255.0
                           green:((CGFloat)rgba[1]) / 255.0
                            blue:((CGFloat)rgba[2]) / 255.0
                           alpha:1.0];
}

enum {
    M2AccentHueBinCount = 36,
    M2AccentSaturationBinCount = 5,
    M2AccentBrightnessBinCount = 4
};

typedef struct {
    CGFloat weight;
    CGFloat red;
    CGFloat green;
    CGFloat blue;
    CGFloat saturation;
    CGFloat brightness;
} M2AccentHistogramBin;

static UIColor *M2VibrantColorFromImage(UIImage *image) {
    if (image == nil || image.CGImage == nil) {
        return nil;
    }

    const size_t width = 40;
    const size_t height = 40;
    const size_t bytesPerRow = width * 4;
    uint8_t *pixels = calloc(height, bytesPerRow);
    if (pixels == NULL) {
        return nil;
    }

    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    if (colorSpace == nil) {
        free(pixels);
        return nil;
    }

    CGBitmapInfo bitmapInfo = (CGBitmapInfo)(kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);
    CGContextRef bitmapContext = CGBitmapContextCreate(pixels,
                                                       width,
                                                       height,
                                                       8,
                                                       bytesPerRow,
                                                       colorSpace,
                                                       bitmapInfo);
    CGColorSpaceRelease(colorSpace);
    if (bitmapContext == NULL) {
        free(pixels);
        return nil;
    }

    CGContextSetInterpolationQuality(bitmapContext, kCGInterpolationHigh);
    CGContextDrawImage(bitmapContext, CGRectMake(0.0, 0.0, width, height), image.CGImage);

    M2AccentHistogramBin bins[M2AccentHueBinCount * M2AccentSaturationBinCount * M2AccentBrightnessBinCount] = {0};
    static const CGFloat kCenterMaxDistance = 0.70710678;

    CGFloat bestScore = -1.0;
    NSUInteger bestBinIndex = NSNotFound;

    for (size_t y = 0; y < height; y += 1) {
        for (size_t x = 0; x < width; x += 1) {
            size_t offset = y * bytesPerRow + x * 4;
            CGFloat alpha = ((CGFloat)pixels[offset + 3]) / 255.0;
            if (alpha < 0.14) {
                continue;
            }

            CGFloat red = ((CGFloat)pixels[offset + 0]) / 255.0;
            CGFloat green = ((CGFloat)pixels[offset + 1]) / 255.0;
            CGFloat blue = ((CGFloat)pixels[offset + 2]) / 255.0;
            UIColor *candidate = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];

            CGFloat hue = 0.0;
            CGFloat saturation = 0.0;
            CGFloat brightness = 0.0;
            CGFloat outAlpha = 1.0;
            if (![candidate getHue:&hue saturation:&saturation brightness:&brightness alpha:&outAlpha]) {
                continue;
            }

            if (saturation < 0.12 || brightness < 0.16 || brightness > 0.98) {
                continue;
            }

            NSUInteger hueIndex = MIN((NSUInteger)floor(hue * (CGFloat)M2AccentHueBinCount), (NSUInteger)(M2AccentHueBinCount - 1));
            NSUInteger saturationIndex = MIN((NSUInteger)floor(saturation * (CGFloat)M2AccentSaturationBinCount), (NSUInteger)(M2AccentSaturationBinCount - 1));
            NSUInteger brightnessIndex = MIN((NSUInteger)floor(brightness * (CGFloat)M2AccentBrightnessBinCount), (NSUInteger)(M2AccentBrightnessBinCount - 1));
            NSUInteger binIndex = (hueIndex * M2AccentSaturationBinCount * M2AccentBrightnessBinCount) +
            (saturationIndex * M2AccentBrightnessBinCount) +
            brightnessIndex;

            CGFloat normalizedX = (((CGFloat)x) + 0.5) / ((CGFloat)width);
            CGFloat normalizedY = (((CGFloat)y) + 0.5) / ((CGFloat)height);
            CGFloat distance = hypot(normalizedX - 0.5, normalizedY - 0.5) / kCenterMaxDistance;
            distance = MIN(MAX(distance, 0.0), 1.0);
            CGFloat centerBias = 1.0 - (distance * 0.32);
            CGFloat weight = alpha * (0.34 + saturation * 0.66) * (0.42 + brightness * 0.58) * centerBias;

            bins[binIndex].weight += weight;
            bins[binIndex].red += red * weight;
            bins[binIndex].green += green * weight;
            bins[binIndex].blue += blue * weight;
            bins[binIndex].saturation += saturation * weight;
            bins[binIndex].brightness += brightness * weight;

            CGFloat averageSaturation = bins[binIndex].saturation / bins[binIndex].weight;
            CGFloat averageBrightness = bins[binIndex].brightness / bins[binIndex].weight;
            CGFloat score = bins[binIndex].weight *
            (0.55 + averageSaturation * 0.45) *
            (0.46 + averageBrightness * 0.54);
            if (score > bestScore) {
                bestScore = score;
                bestBinIndex = binIndex;
            }
        }
    }

    CGContextRelease(bitmapContext);
    free(pixels);

    if (bestBinIndex == NSNotFound || bins[bestBinIndex].weight <= 0.0) {
        return nil;
    }

    M2AccentHistogramBin bestBin = bins[bestBinIndex];
    return [UIColor colorWithRed:(bestBin.red / bestBin.weight)
                           green:(bestBin.green / bestBin.weight)
                            blue:(bestBin.blue / bestBin.weight)
                           alpha:1.0];
}

static UIColor *M2NormalizedAccentColor(UIColor *rawColor, CGFloat minimumSaturation) {
    if (rawColor == nil) {
        return nil;
    }

    CGFloat hue = 0.0;
    CGFloat saturation = 0.0;
    CGFloat brightness = 0.0;
    CGFloat alpha = 1.0;
    if (![rawColor getHue:&hue saturation:&saturation brightness:&brightness alpha:&alpha]) {
        return nil;
    }

    if (saturation < minimumSaturation) {
        return nil;
    }

    saturation = MIN(MAX(saturation * 1.18, 0.40), 0.96);
    brightness = MIN(MAX(brightness * 0.92, 0.38), 0.90);
    return [UIColor colorWithHue:hue saturation:saturation brightness:brightness alpha:1.0];
}

static UIColor *M2BlendedAccentColor(UIColor *primaryColor, UIColor *secondaryColor, CGFloat secondaryWeight) {
    if (primaryColor == nil) {
        return secondaryColor;
    }
    if (secondaryColor == nil) {
        return primaryColor;
    }

    CGFloat primaryRed = 0.0;
    CGFloat primaryGreen = 0.0;
    CGFloat primaryBlue = 0.0;
    CGFloat primaryAlpha = 1.0;
    CGFloat secondaryRed = 0.0;
    CGFloat secondaryGreen = 0.0;
    CGFloat secondaryBlue = 0.0;
    CGFloat secondaryAlpha = 1.0;

    BOOL hasPrimaryRGB = [primaryColor getRed:&primaryRed
                                        green:&primaryGreen
                                         blue:&primaryBlue
                                        alpha:&primaryAlpha];
    BOOL hasSecondaryRGB = [secondaryColor getRed:&secondaryRed
                                            green:&secondaryGreen
                                             blue:&secondaryBlue
                                            alpha:&secondaryAlpha];
    if (!hasPrimaryRGB || !hasSecondaryRGB) {
        return primaryColor;
    }

    CGFloat clampedWeight = MIN(MAX(secondaryWeight, 0.0), 1.0);
    CGFloat primaryWeight = 1.0 - clampedWeight;
    return [UIColor colorWithRed:(primaryRed * primaryWeight + secondaryRed * clampedWeight)
                           green:(primaryGreen * primaryWeight + secondaryGreen * clampedWeight)
                            blue:(primaryBlue * primaryWeight + secondaryBlue * clampedWeight)
                           alpha:1.0];
}

@implementation M2ArtworkAccentColorService

+ (UIColor *)dominantAccentColorForImage:(nullable UIImage *)image
                                fallback:(UIColor *)fallbackColor {
    UIColor *fallback = fallbackColor ?: [UIColor colorWithRed:1.0 green:0.83 blue:0.08 alpha:1.0];
    if (image == nil) {
        return fallback;
    }

    UIColor *vibrantColor = M2NormalizedAccentColor(M2VibrantColorFromImage(image), 0.10);
    UIColor *averageColor = M2NormalizedAccentColor(M2AverageColorFromImage(image), 0.06);

    if (vibrantColor != nil && averageColor != nil) {
        return M2BlendedAccentColor(vibrantColor, averageColor, 0.20);
    }

    if (vibrantColor != nil) {
        return vibrantColor;
    }

    if (averageColor != nil) {
        return averageColor;
    }

    return fallback;
}

@end

static NSSet<NSString *> *M2AudioExtensions(void) {
    static NSSet<NSString *> *extensions;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        extensions = [NSSet setWithArray:@[@"mp3", @"m4a", @"wav", @"aac", @"flac", @"aiff", @"caf", @"alac"]];
    });
    return extensions;
}

static UIImage *M2PlaceholderArtwork(NSString *seed, CGSize size) {
    CGSize normalizedSize = CGSizeMake(MAX(size.width, 2.0), MAX(size.height, 2.0));
    NSUInteger hash = seed.hash;

    CGFloat hue = (hash % 255) / 255.0;
    UIColor *fillColor = [UIColor colorWithHue:hue saturation:0.18 brightness:0.34 alpha:1.0];

    UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:normalizedSize];
    return [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull context) {
        [fillColor setFill];
        UIRectFill(CGRectMake(0, 0, normalizedSize.width, normalizedSize.height));

        UIImageSymbolConfiguration *config = [UIImageSymbolConfiguration configurationWithPointSize:normalizedSize.width * 0.35
                                                                                               weight:UIImageSymbolWeightBold];
        UIImage *symbol = [UIImage systemImageNamed:@"music.note" withConfiguration:config];
        [[UIColor colorWithWhite:1.0 alpha:0.82] setFill];
        [symbol drawInRect:CGRectMake((normalizedSize.width - symbol.size.width) * 0.5,
                                      (normalizedSize.height - symbol.size.height) * 0.5,
                                      symbol.size.width,
                                      symbol.size.height)];
    }];
}

static UIImage *M2CollageCover(NSArray<UIImage *> *images, CGSize size) {
    CGSize normalizedSize = CGSizeMake(MAX(size.width, 2.0), MAX(size.height, 2.0));
    CGFloat gap = MAX(2.0, normalizedSize.width * 0.015);

    NSArray<UIImage *> *usableImages = images;
    if (usableImages.count > 4) {
        usableImages = [usableImages subarrayWithRange:NSMakeRange(0, 4)];
    }

    if (usableImages.count == 0) {
        return M2PlaceholderArtwork(@"playlist-empty", normalizedSize);
    }

    UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:normalizedSize];
    return [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull context) {
        [[UIColor blackColor] setFill];
        UIRectFill(CGRectMake(0, 0, normalizedSize.width, normalizedSize.height));

        if (usableImages.count == 1) {
            [usableImages[0] drawInRect:CGRectMake(0, 0, normalizedSize.width, normalizedSize.height)];
            return;
        }

        if (usableImages.count == 2) {
            CGFloat width = (normalizedSize.width - gap) * 0.5;
            [usableImages[0] drawInRect:CGRectMake(0, 0, width, normalizedSize.height)];
            [usableImages[1] drawInRect:CGRectMake(width + gap, 0, width, normalizedSize.height)];
            return;
        }

        if (usableImages.count == 3) {
            CGFloat leftWidth = floor((normalizedSize.width - gap) * 0.42);
            CGFloat rightWidth = normalizedSize.width - leftWidth - gap;
            CGFloat leftHeight = (normalizedSize.height - gap) * 0.5;

            [usableImages[0] drawInRect:CGRectMake(0, 0, leftWidth, leftHeight)];
            [usableImages[1] drawInRect:CGRectMake(0, leftHeight + gap, leftWidth, leftHeight)];
            [usableImages[2] drawInRect:CGRectMake(leftWidth + gap, 0, rightWidth, normalizedSize.height)];
            return;
        }

        CGFloat tile = (normalizedSize.width - gap) * 0.5;
        [usableImages[0] drawInRect:CGRectMake(0, 0, tile, tile)];
        [usableImages[1] drawInRect:CGRectMake(tile + gap, 0, tile, tile)];
        [usableImages[2] drawInRect:CGRectMake(0, tile + gap, tile, tile)];
        [usableImages[3] drawInRect:CGRectMake(tile + gap, tile + gap, tile, tile)];
    }];
}

static NSData *M2EncodedCoverData(UIImage *image) {
    if (image == nil) {
        return nil;
    }

    NSData *pngData = UIImagePNGRepresentation(image);
    if (pngData.length > 0) {
        return pngData;
    }

    NSData *jpegData = UIImageJPEGRepresentation(image, 0.96);
    if (jpegData.length > 0) {
        return jpegData;
    }

    CGSize fallbackSize = image.size;
    if (fallbackSize.width <= 1.0 || fallbackSize.height <= 1.0) {
        fallbackSize = CGSizeMake(512.0, 512.0);
    }

    UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:fallbackSize];
    UIImage *rendered = [renderer imageWithActions:^(__unused UIGraphicsImageRendererContext * _Nonnull context) {
        [image drawInRect:CGRectMake(0, 0, fallbackSize.width, fallbackSize.height)];
    }];
    return UIImagePNGRepresentation(rendered);
}

#pragma mark - Library

@interface M2LibraryManager ()

@property (nonatomic, copy) NSArray<M2Track *> *cachedTracks;
@property (nonatomic, copy) NSDictionary<NSString *, M2Track *> *tracksByID;
@property (nonatomic, copy) NSDictionary<NSString *, M2Track *> *tracksByRelativeID;
@property (nonatomic, copy) NSDictionary<NSString *, M2Track *> *tracksByFileName;

@end

@implementation M2LibraryManager

+ (instancetype)sharedManager {
    static M2LibraryManager *manager;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        manager = [[M2LibraryManager alloc] init];
    });
    return manager;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        _cachedTracks = @[];
        _tracksByID = @{};
        _tracksByRelativeID = @{};
        _tracksByFileName = @{};
        [self reloadTracks];
    }
    return self;
}

- (NSURL *)musicDirectoryURL {
    NSURL *documentsURL = [NSFileManager.defaultManager URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask].firstObject;
    NSURL *directoryURL = [documentsURL URLByAppendingPathComponent:kMusicFolderName isDirectory:YES];

    NSError *error = nil;
    [NSFileManager.defaultManager createDirectoryAtURL:directoryURL
                            withIntermediateDirectories:YES
                                             attributes:nil
                                                  error:&error];
    if (error != nil) {
        NSLog(@"Cannot create music directory: %@", error.localizedDescription);
    }

    return directoryURL;
}

- (NSString *)filesDropHint {
    return @"Files -> On My iPhone -> M2 -> M2";
}

- (NSArray<M2Track *> *)tracks {
    return self.cachedTracks;
}

- (NSString *)normalizedPathStringFromIdentifier:(NSString *)identifier {
    if (identifier.length == 0) {
        return @"";
    }

    NSString *normalized = [identifier stringByReplacingOccurrencesOfString:@"\\" withString:@"/"];
    if ([normalized hasPrefix:@"file://"]) {
        NSURL *fileURL = [NSURL URLWithString:normalized];
        if (fileURL.fileURL && fileURL.path.length > 0) {
            normalized = fileURL.path;
        }
    }
    return normalized;
}

- (NSString *)relativeTrackLookupKeyForIdentifier:(NSString *)identifier {
    NSString *normalized = [self normalizedPathStringFromIdentifier:identifier];
    if (normalized.length == 0) {
        return @"";
    }

    NSString *documentsToken = [NSString stringWithFormat:@"/Documents/%@/", kMusicFolderName];
    NSRange documentsRange = [normalized rangeOfString:documentsToken options:NSCaseInsensitiveSearch];
    if (documentsRange.location != NSNotFound) {
        NSString *relative = [normalized substringFromIndex:NSMaxRange(documentsRange)];
        while ([relative hasPrefix:@"/"]) {
            relative = [relative substringFromIndex:1];
        }
        return relative.lowercaseString;
    }

    NSString *folderToken = [NSString stringWithFormat:@"/%@/", kMusicFolderName];
    NSRange folderRange = [normalized rangeOfString:folderToken options:(NSCaseInsensitiveSearch | NSBackwardsSearch)];
    if (folderRange.location != NSNotFound && NSMaxRange(folderRange) < normalized.length) {
        NSString *relative = [normalized substringFromIndex:NSMaxRange(folderRange)];
        while ([relative hasPrefix:@"/"]) {
            relative = [relative substringFromIndex:1];
        }
        return relative.lowercaseString;
    }

    if (![normalized hasPrefix:@"/"]) {
        NSString *relative = normalized;
        while ([relative hasPrefix:@"/"]) {
            relative = [relative substringFromIndex:1];
        }
        return relative.lowercaseString;
    }

    return @"";
}

- (NSArray<M2Track *> *)reloadTracks {
    NSURL *musicURL = [self musicDirectoryURL];
    NSFileManager *fileManager = NSFileManager.defaultManager;

    NSMutableArray<M2Track *> *tracks = [NSMutableArray array];
    NSDirectoryEnumerator<NSURL *> *enumerator = [fileManager enumeratorAtURL:musicURL
                                                   includingPropertiesForKeys:@[NSURLIsDirectoryKey, NSURLNameKey]
                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles
                                                                 errorHandler:^BOOL(NSURL * _Nonnull url, NSError * _Nonnull error) {
        NSLog(@"Directory enumeration error for %@: %@", url.path, error.localizedDescription);
        return YES;
    }];

    for (NSURL *fileURL in enumerator) {
        NSNumber *isDirectory = nil;
        [fileURL getResourceValue:&isDirectory forKey:NSURLIsDirectoryKey error:nil];
        if (isDirectory.boolValue) {
            continue;
        }

        NSString *extension = fileURL.pathExtension.lowercaseString;
        if (![M2AudioExtensions() containsObject:extension]) {
            continue;
        }

        M2Track *track = [self trackFromURL:fileURL];
        if (track != nil) {
            [tracks addObject:track];
        }
    }

    [tracks sortUsingComparator:^NSComparisonResult(M2Track * _Nonnull left, M2Track * _Nonnull right) {
        NSComparisonResult titleCompare = [left.title localizedCaseInsensitiveCompare:right.title];
        if (titleCompare != NSOrderedSame) {
            return titleCompare;
        }
        return [left.fileName localizedCaseInsensitiveCompare:right.fileName];
    }];

    NSMutableDictionary<NSString *, M2Track *> *mapping = [NSMutableDictionary dictionaryWithCapacity:tracks.count];
    NSMutableDictionary<NSString *, M2Track *> *relativeMapping = [NSMutableDictionary dictionaryWithCapacity:tracks.count];
    NSMutableDictionary<NSString *, id> *fileNameCandidates = [NSMutableDictionary dictionaryWithCapacity:tracks.count];
    for (M2Track *track in tracks) {
        if (track.identifier.length > 0) {
            mapping[track.identifier] = track;
            NSString *relativeKey = [self relativeTrackLookupKeyForIdentifier:track.identifier];
            if (relativeKey.length > 0 && relativeMapping[relativeKey] == nil) {
                relativeMapping[relativeKey] = track;
            }
        }

        NSString *fileNameKey = track.fileName.lowercaseString;
        if (fileNameKey.length > 0) {
            id existing = fileNameCandidates[fileNameKey];
            if (existing == nil) {
                fileNameCandidates[fileNameKey] = track;
            } else if (![existing isKindOfClass:NSNull.class]) {
                fileNameCandidates[fileNameKey] = NSNull.null;
            }
        }
    }

    NSMutableDictionary<NSString *, M2Track *> *fileNameMapping = [NSMutableDictionary dictionaryWithCapacity:fileNameCandidates.count];
    for (NSString *fileNameKey in fileNameCandidates) {
        id value = fileNameCandidates[fileNameKey];
        if ([value isKindOfClass:M2Track.class]) {
            fileNameMapping[fileNameKey] = (M2Track *)value;
        }
    }

    self.cachedTracks = [tracks copy];
    self.tracksByID = [mapping copy];
    self.tracksByRelativeID = [relativeMapping copy];
    self.tracksByFileName = [fileNameMapping copy];
    return self.cachedTracks;
}

- (nullable M2Track *)trackForIdentifier:(NSString *)identifier {
    if (identifier.length == 0) {
        return nil;
    }

    M2Track *directTrack = self.tracksByID[identifier];
    if (directTrack != nil) {
        return directTrack;
    }

    NSString *normalizedIdentifier = [self normalizedPathStringFromIdentifier:identifier];
    if (normalizedIdentifier.length > 0 && ![normalizedIdentifier isEqualToString:identifier]) {
        directTrack = self.tracksByID[normalizedIdentifier];
        if (directTrack != nil) {
            return directTrack;
        }
    }

    NSString *relativeKey = [self relativeTrackLookupKeyForIdentifier:identifier];
    if (relativeKey.length > 0) {
        M2Track *relativeTrack = self.tracksByRelativeID[relativeKey];
        if (relativeTrack != nil) {
            return relativeTrack;
        }
    }

    NSString *fileNameKey = [self normalizedPathStringFromIdentifier:identifier].lastPathComponent.lowercaseString;
    if (fileNameKey.length > 0) {
        M2Track *fileNameTrack = self.tracksByFileName[fileNameKey];
        if (fileNameTrack != nil) {
            return fileNameTrack;
        }
    }

    return nil;
}

- (BOOL)deleteTrackWithIdentifier:(NSString *)identifier error:(NSError * _Nullable __autoreleasing *)error {
    if (identifier.length == 0) {
        if (error != NULL) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain
                                         code:NSFileNoSuchFileError
                                     userInfo:@{NSLocalizedDescriptionKey: @"Track identifier is empty."}];
        }
        return NO;
    }

    M2Track *track = [self trackForIdentifier:identifier];
    NSURL *fileURL = track.url;
    if (fileURL == nil && track.identifier.length > 0) {
        fileURL = [NSURL fileURLWithPath:track.identifier];
    }
    if (fileURL == nil) {
        fileURL = [NSURL fileURLWithPath:[self normalizedPathStringFromIdentifier:identifier]];
    }

    if (![NSFileManager.defaultManager fileExistsAtPath:fileURL.path]) {
        if (error != NULL) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain
                                         code:NSFileNoSuchFileError
                                     userInfo:@{NSLocalizedDescriptionKey: @"Track file does not exist."}];
        }
        return NO;
    }

    NSError *removeError = nil;
    BOOL removed = [NSFileManager.defaultManager removeItemAtURL:fileURL error:&removeError];
    if (!removed || removeError != nil) {
        if (error != NULL) {
            *error = removeError;
        }
        return NO;
    }

    [self reloadTracks];
    return YES;
}

- (nullable M2Track *)trackFromURL:(NSURL *)fileURL {
    AVURLAsset *asset = [AVURLAsset URLAssetWithURL:fileURL options:nil];

    NSString *fallbackTitle = fileURL.lastPathComponent.stringByDeletingPathExtension;
    NSString *title = [self metadataStringForCommonKey:AVMetadataCommonKeyTitle asset:asset];
    if (title.length == 0) {
        title = fallbackTitle;
    }

    NSString *artist = [self metadataStringForCommonKey:AVMetadataCommonKeyArtist asset:asset];

    NSTimeInterval duration = CMTimeGetSeconds(asset.duration);
    if (!isfinite(duration) || duration < 0) {
        duration = 0;
    }

    UIImage *artwork = [self artworkFromAsset:asset];
    if (artwork == nil) {
        artwork = M2PlaceholderArtwork(title, CGSizeMake(180, 180));
    }

    M2Track *track = [[M2Track alloc] init];
    track.identifier = fileURL.path;
    track.title = title;
    track.artist = artist ?: @"";
    track.fileName = fileURL.lastPathComponent;
    track.url = fileURL;
    track.duration = duration;
    track.artwork = artwork;

    return track;
}

- (NSString *)metadataStringForCommonKey:(AVMetadataKey)key asset:(AVAsset *)asset {
    NSArray<AVMetadataItem *> *items = [AVMetadataItem metadataItemsFromArray:asset.commonMetadata
                                                                       withKey:key
                                                                      keySpace:AVMetadataKeySpaceCommon];
    AVMetadataItem *item = items.firstObject;
    return item.stringValue ?: @"";
}

- (nullable UIImage *)artworkFromAsset:(AVAsset *)asset {
    for (AVMetadataItem *item in asset.commonMetadata) {
        if (![item.commonKey isEqualToString:AVMetadataCommonKeyArtwork]) {
            continue;
        }

        if ([item.value isKindOfClass:NSData.class]) {
            UIImage *image = [UIImage imageWithData:(NSData *)item.value];
            if (image != nil) {
                return image;
            }
        } else if ([item.value isKindOfClass:UIImage.class]) {
            return (UIImage *)item.value;
        }
    }

    return nil;
}

@end

#pragma mark - Playlists

@interface M2PlaylistStore ()

@property (nonatomic, copy) NSArray<M2Playlist *> *cachedPlaylists;

@end

@implementation M2PlaylistStore

+ (instancetype)sharedStore {
    static M2PlaylistStore *store;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        store = [[M2PlaylistStore alloc] init];
    });
    return store;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        _cachedPlaylists = @[];
        [self reloadPlaylists];
    }
    return self;
}

- (NSArray<M2Playlist *> *)playlists {
    return self.cachedPlaylists;
}

- (nullable NSArray<NSDictionary<NSString *, id> *> *)playlistDictionariesFromArrayObject:(id)object {
    if (![object isKindOfClass:NSArray.class]) {
        return nil;
    }

    NSArray *rawArray = (NSArray *)object;
    NSMutableArray<NSDictionary<NSString *, id> *> *dictionaries = [NSMutableArray arrayWithCapacity:rawArray.count];
    for (id item in rawArray) {
        if ([item isKindOfClass:NSDictionary.class]) {
            [dictionaries addObject:item];
        }
    }
    return [dictionaries copy];
}

- (NSArray<NSDictionary<NSString *, id> *> *)playlistDictionariesFromLegacyDefaults {
    NSUserDefaults *defaults = NSUserDefaults.standardUserDefaults;
    for (NSString *legacyKey in M2LegacyPlaylistsDefaultsKeys()) {
        id legacyObject = [defaults objectForKey:legacyKey];
        NSArray<NSDictionary<NSString *, id> *> *legacyDictionaries = [self playlistDictionariesFromArrayObject:legacyObject];
        if (legacyDictionaries.count > 0) {
            [defaults setObject:legacyDictionaries forKey:kPlaylistsDefaultsKey];
            return legacyDictionaries;
        }
    }
    return @[];
}

- (nullable NSURL *)playlistsBackupFileURL {
    NSFileManager *fileManager = NSFileManager.defaultManager;
    NSURL *baseURL = [fileManager URLsForDirectory:NSApplicationSupportDirectory inDomains:NSUserDomainMask].firstObject;
    if (baseURL == nil) {
        baseURL = [fileManager URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask].firstObject;
    }
    if (baseURL == nil) {
        return nil;
    }

    NSURL *directoryURL = [baseURL URLByAppendingPathComponent:@"M2" isDirectory:YES];
    NSError *directoryError = nil;
    [fileManager createDirectoryAtURL:directoryURL
          withIntermediateDirectories:YES
                           attributes:nil
                                error:&directoryError];
    if (directoryError != nil) {
        NSLog(@"Cannot create playlists backup directory: %@", directoryError.localizedDescription);
        return nil;
    }

    return [directoryURL URLByAppendingPathComponent:kPlaylistsBackupFileName];
}

- (NSArray<NSDictionary<NSString *, id> *> *)playlistDictionariesFromBackupFile {
    NSURL *backupURL = [self playlistsBackupFileURL];
    if (backupURL == nil || ![NSFileManager.defaultManager fileExistsAtPath:backupURL.path]) {
        return @[];
    }

    NSData *data = [NSData dataWithContentsOfURL:backupURL];
    if (data.length == 0) {
        return @[];
    }

    NSError *jsonError = nil;
    id object = [NSJSONSerialization JSONObjectWithData:data options:0 error:&jsonError];
    if (jsonError != nil) {
        NSLog(@"Playlists backup JSON parse error: %@", jsonError.localizedDescription);
        return @[];
    }

    return [self playlistDictionariesFromArrayObject:object] ?: @[];
}

- (void)writePlaylistsBackupWithDictionaries:(NSArray<NSDictionary<NSString *, id> *> *)dictionaries {
    NSURL *backupURL = [self playlistsBackupFileURL];
    if (backupURL == nil) {
        return;
    }

    NSArray<NSDictionary<NSString *, id> *> *payload = dictionaries ?: @[];
    NSError *jsonError = nil;
    NSData *data = [NSJSONSerialization dataWithJSONObject:payload options:0 error:&jsonError];
    if (jsonError != nil || data.length == 0) {
        NSLog(@"Cannot encode playlists backup JSON: %@", jsonError.localizedDescription);
        return;
    }

    NSError *writeError = nil;
    [data writeToURL:backupURL options:NSDataWritingAtomic error:&writeError];
    if (writeError != nil) {
        NSLog(@"Cannot write playlists backup file: %@", writeError.localizedDescription);
    }
}

- (BOOL)repairTrackReferencesIfNeededForPlaylists:(NSArray<M2Playlist *> *)playlists {
    if (playlists.count == 0) {
        return NO;
    }

    M2LibraryManager *library = M2LibraryManager.sharedManager;
    BOOL changed = NO;

    for (M2Playlist *playlist in playlists) {
        if (playlist.trackIDs.count == 0) {
            continue;
        }

        NSMutableArray<NSString *> *resolvedTrackIDs = [NSMutableArray arrayWithCapacity:playlist.trackIDs.count];
        NSMutableSet<NSString *> *seenIDs = [NSMutableSet setWithCapacity:playlist.trackIDs.count];
        BOOL playlistChanged = NO;

        for (NSString *trackID in playlist.trackIDs) {
            if (![trackID isKindOfClass:NSString.class] || trackID.length == 0) {
                continue;
            }

            NSString *normalizedID = trackID;
            M2Track *resolvedTrack = [library trackForIdentifier:trackID];
            if (resolvedTrack.identifier.length > 0) {
                normalizedID = resolvedTrack.identifier;
            }

            if (normalizedID.length == 0 || [seenIDs containsObject:normalizedID]) {
                playlistChanged = YES;
                continue;
            }

            [resolvedTrackIDs addObject:normalizedID];
            [seenIDs addObject:normalizedID];
            if (![normalizedID isEqualToString:trackID]) {
                playlistChanged = YES;
            }
        }

        if (playlistChanged && ![playlist.trackIDs isEqualToArray:resolvedTrackIDs]) {
            playlist.trackIDs = [resolvedTrackIDs copy];
            changed = YES;
        }
    }

    return changed;
}

- (void)reloadPlaylists {
    NSUserDefaults *defaults = NSUserDefaults.standardUserDefaults;
    id currentObject = [defaults objectForKey:kPlaylistsDefaultsKey];
    NSArray<NSDictionary<NSString *, id> *> * _Nullable storedDictionaries = [self playlistDictionariesFromArrayObject:currentObject];
    BOOL currentLooksCorrupt = ([currentObject isKindOfClass:NSArray.class] &&
                                ((NSArray *)currentObject).count > 0 &&
                                storedDictionaries.count == 0);

    if (currentObject == nil || storedDictionaries == nil || currentLooksCorrupt) {
        NSArray<NSDictionary<NSString *, id> *> *legacy = [self playlistDictionariesFromLegacyDefaults];
        if (legacy.count > 0) {
            storedDictionaries = legacy;
        } else {
            NSArray<NSDictionary<NSString *, id> *> *backup = [self playlistDictionariesFromBackupFile];
            if (backup.count > 0) {
                storedDictionaries = backup;
                [defaults setObject:backup forKey:kPlaylistsDefaultsKey];
            }
        }
    }

    if (storedDictionaries == nil) {
        storedDictionaries = @[];
    }

    NSMutableArray<M2Playlist *> *loaded = [NSMutableArray arrayWithCapacity:storedDictionaries.count];
    for (NSDictionary<NSString *, id> *value in storedDictionaries) {
        M2Playlist *playlist = [M2Playlist playlistFromDictionary:value];
        if (playlist != nil) {
            [loaded addObject:playlist];
        }
    }

    BOOL repairedReferences = [self repairTrackReferencesIfNeededForPlaylists:loaded];
    self.cachedPlaylists = [loaded copy];
    if (repairedReferences) {
        [self persistPlaylists];
    } else if (storedDictionaries.count > 0 &&
               (currentObject == nil || ![currentObject isKindOfClass:NSArray.class] || currentLooksCorrupt)) {
        [self writePlaylistsBackupWithDictionaries:storedDictionaries];
    }
}

- (nullable M2Playlist *)playlistWithID:(NSString *)playlistID {
    for (M2Playlist *playlist in self.cachedPlaylists) {
        if ([playlist.playlistID isEqualToString:playlistID]) {
            return playlist;
        }
    }
    return nil;
}

- (nullable M2Playlist *)addPlaylistWithName:(NSString *)name
                                    trackIDs:(NSArray<NSString *> *)trackIDs
                                  coverImage:(nullable UIImage *)coverImage {
    NSString *trimmedName = [name stringByTrimmingCharactersInSet:NSCharacterSet.whitespaceAndNewlineCharacterSet];
    if (trimmedName.length == 0) {
        return nil;
    }

    NSMutableArray<NSString *> *normalizedTrackIDs = [NSMutableArray arrayWithCapacity:trackIDs.count];
    NSMutableSet<NSString *> *seenIDs = [NSMutableSet setWithCapacity:trackIDs.count];

    for (NSString *trackID in trackIDs) {
        if (![trackID isKindOfClass:NSString.class] || trackID.length == 0 || [seenIDs containsObject:trackID]) {
            continue;
        }
        [normalizedTrackIDs addObject:trackID];
        [seenIDs addObject:trackID];
    }

    if (normalizedTrackIDs.count == 0) {
        return nil;
    }

    M2Playlist *playlist = [[M2Playlist alloc] init];
    playlist.playlistID = NSUUID.UUID.UUIDString;
    playlist.name = trimmedName;
    playlist.trackIDs = [normalizedTrackIDs copy];

    if (coverImage != nil) {
        NSString *coverFileName = [NSString stringWithFormat:@"%@.png", playlist.playlistID];
        NSURL *coverURL = [[self playlistCoversDirectoryURL] URLByAppendingPathComponent:coverFileName];
        NSData *coverData = M2EncodedCoverData(coverImage);
        if (coverData != nil && [coverData writeToURL:coverURL atomically:YES]) {
            playlist.customCoverFileName = coverFileName;
        }
    }

    NSMutableArray<M2Playlist *> *updated = [self.cachedPlaylists mutableCopy];
    [updated addObject:playlist];
    self.cachedPlaylists = [updated copy];

    [self persistPlaylists];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];

    return playlist;
}

- (BOOL)renamePlaylistWithID:(NSString *)playlistID newName:(NSString *)newName {
    NSString *trimmedName = [newName stringByTrimmingCharactersInSet:NSCharacterSet.whitespaceAndNewlineCharacterSet];
    if (playlistID.length == 0 || trimmedName.length == 0) {
        return NO;
    }

    M2Playlist *playlist = [self playlistWithID:playlistID];
    if (playlist == nil) {
        return NO;
    }

    if ([playlist.name isEqualToString:trimmedName]) {
        return YES;
    }

    playlist.name = trimmedName;
    [self persistPlaylists];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];
    return YES;
}

- (BOOL)deletePlaylistWithID:(NSString *)playlistID {
    if (playlistID.length == 0 || self.cachedPlaylists.count == 0) {
        return NO;
    }

    NSUInteger index = NSNotFound;
    for (NSUInteger i = 0; i < self.cachedPlaylists.count; i += 1) {
        M2Playlist *playlist = self.cachedPlaylists[i];
        if ([playlist.playlistID isEqualToString:playlistID]) {
            index = i;
            break;
        }
    }

    if (index == NSNotFound) {
        return NO;
    }

    M2Playlist *playlist = self.cachedPlaylists[index];
    [self removeCustomCoverIfNeededForPlaylist:playlist];

    NSMutableArray<M2Playlist *> *updated = [self.cachedPlaylists mutableCopy];
    [updated removeObjectAtIndex:index];
    self.cachedPlaylists = [updated copy];

    [self persistPlaylists];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];
    return YES;
}

- (BOOL)addTrackIDs:(NSArray<NSString *> *)trackIDs toPlaylistID:(NSString *)playlistID {
    if (playlistID.length == 0 || trackIDs.count == 0) {
        return NO;
    }

    M2Playlist *playlist = [self playlistWithID:playlistID];
    if (playlist == nil) {
        return NO;
    }

    NSMutableArray<NSString *> *updatedTrackIDs = [playlist.trackIDs mutableCopy] ?: [NSMutableArray array];
    NSMutableSet<NSString *> *seenIDs = [NSMutableSet setWithArray:updatedTrackIDs];
    BOOL changed = NO;

    for (NSString *trackID in trackIDs) {
        if (![trackID isKindOfClass:NSString.class] || trackID.length == 0 || [seenIDs containsObject:trackID]) {
            continue;
        }

        [updatedTrackIDs addObject:trackID];
        [seenIDs addObject:trackID];
        changed = YES;
    }

    if (!changed) {
        return NO;
    }

    playlist.trackIDs = [updatedTrackIDs copy];
    [self persistPlaylists];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];
    return YES;
}

- (BOOL)replaceTrackIDs:(NSArray<NSString *> *)trackIDs forPlaylistID:(NSString *)playlistID {
    if (playlistID.length == 0) {
        return NO;
    }

    M2Playlist *playlist = [self playlistWithID:playlistID];
    if (playlist == nil) {
        return NO;
    }

    NSMutableArray<NSString *> *normalizedTrackIDs = [NSMutableArray arrayWithCapacity:trackIDs.count];
    NSMutableSet<NSString *> *seenIDs = [NSMutableSet setWithCapacity:trackIDs.count];
    for (NSString *trackID in trackIDs) {
        if (![trackID isKindOfClass:NSString.class] || trackID.length == 0 || [seenIDs containsObject:trackID]) {
            continue;
        }
        [normalizedTrackIDs addObject:trackID];
        [seenIDs addObject:trackID];
    }

    NSArray<NSString *> *updatedIDs = [normalizedTrackIDs copy];
    if ([playlist.trackIDs isEqualToArray:updatedIDs]) {
        return YES;
    }

    playlist.trackIDs = updatedIDs;
    [self persistPlaylists];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];
    return YES;
}

- (BOOL)removeTrackID:(NSString *)trackID fromPlaylistID:(NSString *)playlistID {
    if (trackID.length == 0 || playlistID.length == 0) {
        return NO;
    }

    M2Playlist *playlist = [self playlistWithID:playlistID];
    if (playlist == nil || playlist.trackIDs.count == 0) {
        return NO;
    }

    NSMutableArray<NSString *> *updated = [playlist.trackIDs mutableCopy];
    NSUInteger initialCount = updated.count;
    [updated removeObject:trackID];
    if (updated.count == initialCount) {
        return NO;
    }

    playlist.trackIDs = [updated copy];
    [self persistPlaylists];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];
    return YES;
}

- (BOOL)removeTrackIDFromAllPlaylists:(NSString *)trackID {
    if (trackID.length == 0 || self.cachedPlaylists.count == 0) {
        return NO;
    }

    BOOL changed = NO;
    for (M2Playlist *playlist in self.cachedPlaylists) {
        if (playlist.trackIDs.count == 0) {
            continue;
        }

        NSMutableArray<NSString *> *updated = [playlist.trackIDs mutableCopy];
        NSUInteger initialCount = updated.count;
        [updated removeObject:trackID];
        if (updated.count != initialCount) {
            playlist.trackIDs = [updated copy];
            changed = YES;
        }
    }

    if (!changed) {
        return NO;
    }

    [self persistPlaylists];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];
    return YES;
}

- (BOOL)setCustomCoverImage:(nullable UIImage *)coverImage forPlaylistID:(NSString *)playlistID {
    if (playlistID.length == 0) {
        return NO;
    }

    M2Playlist *playlist = [self playlistWithID:playlistID];
    if (playlist == nil) {
        return NO;
    }

    if (coverImage == nil) {
        if (playlist.customCoverFileName.length == 0) {
            return YES;
        }

        [self removeCustomCoverIfNeededForPlaylist:playlist];
        playlist.customCoverFileName = nil;
        [self persistPlaylists];
        [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];
        return YES;
    }

    NSString *coverFileName = [NSString stringWithFormat:@"%@.png", playlist.playlistID];
    NSURL *coverURL = [[self playlistCoversDirectoryURL] URLByAppendingPathComponent:coverFileName];
    NSData *coverData = M2EncodedCoverData(coverImage);
    if (coverData == nil || ![coverData writeToURL:coverURL atomically:YES]) {
        return NO;
    }

    playlist.customCoverFileName = coverFileName;
    [self persistPlaylists];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaylistsDidChangeNotification object:nil];
    return YES;
}

- (NSArray<M2Track *> *)tracksForPlaylist:(M2Playlist *)playlist library:(M2LibraryManager *)library {
    NSMutableArray<M2Track *> *tracks = [NSMutableArray arrayWithCapacity:playlist.trackIDs.count];
    for (NSString *trackID in playlist.trackIDs) {
        M2Track *track = [library trackForIdentifier:trackID];
        if (track != nil) {
            [tracks addObject:track];
        }
    }
    return [tracks copy];
}

- (UIImage *)coverForPlaylist:(M2Playlist *)playlist
                      library:(M2LibraryManager *)library
                         size:(CGSize)size {
    UIImage *customCover = [self customCoverForPlaylist:playlist];
    if (customCover != nil) {
        return customCover;
    }

    NSArray<M2Track *> *playlistTracks = [self tracksForPlaylist:playlist library:library];
    NSMutableArray<UIImage *> *images = [NSMutableArray arrayWithCapacity:4];
    for (NSInteger index = 0; index < MIN(playlistTracks.count, 4); index += 1) {
        [images addObject:playlistTracks[index].artwork ?: M2PlaceholderArtwork(playlistTracks[index].title, size)];
    }

    if (images.count == 0) {
        return M2PlaceholderArtwork(playlist.name, size);
    }

    return M2CollageCover(images, size);
}

- (void)persistPlaylists {
    NSMutableArray<NSDictionary<NSString *, id> *> *data = [NSMutableArray arrayWithCapacity:self.cachedPlaylists.count];
    for (M2Playlist *playlist in self.cachedPlaylists) {
        [data addObject:[playlist dictionaryRepresentation]];
    }
    [NSUserDefaults.standardUserDefaults setObject:data forKey:kPlaylistsDefaultsKey];
    [self writePlaylistsBackupWithDictionaries:data];
}

- (NSURL *)playlistCoversDirectoryURL {
    NSURL *documentsURL = [NSFileManager.defaultManager URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask].firstObject;
    NSURL *directoryURL = [documentsURL URLByAppendingPathComponent:kPlaylistCoverFolderName isDirectory:YES];

    NSError *error = nil;
    [NSFileManager.defaultManager createDirectoryAtURL:directoryURL
                            withIntermediateDirectories:YES
                                             attributes:nil
                                                  error:&error];
    if (error != nil) {
        NSLog(@"Cannot create playlist cover directory: %@", error.localizedDescription);
    }

    return directoryURL;
}

- (nullable UIImage *)customCoverForPlaylist:(M2Playlist *)playlist {
    if (playlist.customCoverFileName.length == 0) {
        return nil;
    }

    NSURL *coverURL = [[self playlistCoversDirectoryURL] URLByAppendingPathComponent:playlist.customCoverFileName];
    if (![NSFileManager.defaultManager fileExistsAtPath:coverURL.path]) {
        return nil;
    }

    return [UIImage imageWithContentsOfFile:coverURL.path];
}

- (void)removeCustomCoverIfNeededForPlaylist:(M2Playlist *)playlist {
    if (playlist.customCoverFileName.length == 0) {
        return;
    }

    NSURL *coverURL = [[self playlistCoversDirectoryURL] URLByAppendingPathComponent:playlist.customCoverFileName];
    if (![NSFileManager.defaultManager fileExistsAtPath:coverURL.path]) {
        return;
    }

    NSError *error = nil;
    [NSFileManager.defaultManager removeItemAtURL:coverURL error:&error];
    if (error != nil) {
        NSLog(@"Cannot remove cover file: %@", error.localizedDescription);
    }
}

@end

#pragma mark - Favorites

@interface M2FavoritesStore ()

@property (nonatomic, strong) NSMutableOrderedSet<NSString *> *favoriteIDs;

@end

@implementation M2FavoritesStore

+ (instancetype)sharedStore {
    static M2FavoritesStore *store;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        store = [[M2FavoritesStore alloc] init];
    });
    return store;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        _favoriteIDs = [NSMutableOrderedSet orderedSet];
        [self reloadFavoritesFromDefaults];
    }
    return self;
}

- (NSArray<NSString *> *)favoriteTrackIDs {
    return self.favoriteIDs.array ?: @[];
}

- (NSString *)canonicalFavoriteIDForTrackID:(NSString *)trackID {
    if (trackID.length == 0) {
        return @"";
    }

    M2Track *resolvedTrack = [M2LibraryManager.sharedManager trackForIdentifier:trackID];
    if (resolvedTrack.identifier.length > 0) {
        return resolvedTrack.identifier;
    }

    return trackID;
}

- (NSIndexSet *)indexesForFavoritesMatchingTrackID:(NSString *)trackID {
    NSMutableIndexSet *indexes = [NSMutableIndexSet indexSet];
    if (trackID.length == 0 || self.favoriteIDs.count == 0) {
        return indexes;
    }

    NSString *targetCanonicalID = [self canonicalFavoriteIDForTrackID:trackID];
    if (targetCanonicalID.length == 0) {
        return indexes;
    }

    [self.favoriteIDs enumerateObjectsUsingBlock:^(NSString * _Nonnull storedTrackID, NSUInteger idx, __unused BOOL * _Nonnull stop) {
        NSString *storedCanonicalID = [self canonicalFavoriteIDForTrackID:storedTrackID];
        if ([storedCanonicalID isEqualToString:targetCanonicalID]) {
            [indexes addIndex:idx];
        }
    }];
    return indexes;
}

- (void)normalizeFavoriteTrackIDsIfNeeded {
    if (self.favoriteIDs.count == 0) {
        return;
    }

    NSMutableOrderedSet<NSString *> *normalized = [NSMutableOrderedSet orderedSetWithCapacity:self.favoriteIDs.count];
    BOOL changed = NO;

    for (NSString *storedTrackID in self.favoriteIDs) {
        NSString *canonicalID = [self canonicalFavoriteIDForTrackID:storedTrackID];
        if (canonicalID.length == 0) {
            changed = YES;
            continue;
        }

        if (![canonicalID isEqualToString:storedTrackID]) {
            changed = YES;
        }
        if ([normalized containsObject:canonicalID]) {
            changed = YES;
            continue;
        }
        [normalized addObject:canonicalID];
    }

    if (!changed) {
        return;
    }

    self.favoriteIDs = normalized;
    [self persistFavorites];
}

- (BOOL)isTrackFavoriteByID:(NSString *)trackID {
    if (trackID.length == 0) {
        return NO;
    }
    return [self indexesForFavoritesMatchingTrackID:trackID].count > 0;
}

- (void)setTrackID:(NSString *)trackID favorite:(BOOL)favorite {
    if (trackID.length == 0) {
        return;
    }

    NSIndexSet *matchingIndexes = [self indexesForFavoritesMatchingTrackID:trackID];
    BOOL alreadyFavorite = matchingIndexes.count > 0;
    NSString *canonicalID = [self canonicalFavoriteIDForTrackID:trackID];
    if (canonicalID.length == 0) {
        return;
    }

    if (!favorite && !alreadyFavorite) {
        return;
    }

    if (favorite) {
        BOOL alreadyCanonicalOnly = (matchingIndexes.count == 1 &&
                                     [[self.favoriteIDs objectAtIndex:matchingIndexes.firstIndex] isEqualToString:canonicalID]);
        if (alreadyCanonicalOnly) {
            return;
        }

        if (matchingIndexes.count > 0) {
            [self.favoriteIDs removeObjectsAtIndexes:matchingIndexes];
        }
        [self.favoriteIDs addObject:canonicalID];
    } else {
        [self.favoriteIDs removeObjectsAtIndexes:matchingIndexes];
    }

    [self persistFavorites];
    [NSNotificationCenter.defaultCenter postNotificationName:M2FavoritesDidChangeNotification object:nil];
}

- (void)toggleFavoriteForTrackID:(NSString *)trackID {
    [self setTrackID:trackID favorite:![self isTrackFavoriteByID:trackID]];
}

- (NSArray<M2Track *> *)favoriteTracksWithLibrary:(M2LibraryManager *)library {
    NSMutableArray<M2Track *> *tracks = [NSMutableArray arrayWithCapacity:self.favoriteIDs.count];
    NSMutableSet<NSString *> *seenTrackIDs = [NSMutableSet setWithCapacity:self.favoriteIDs.count];
    for (NSString *trackID in self.favoriteIDs) {
        M2Track *track = [library trackForIdentifier:trackID];
        if (track != nil && track.identifier.length > 0 && ![seenTrackIDs containsObject:track.identifier]) {
            [seenTrackIDs addObject:track.identifier];
            [tracks addObject:track];
        }
    }
    return tracks.copy;
}

- (void)reloadFavoritesFromDefaults {
    NSArray *stored = [NSUserDefaults.standardUserDefaults arrayForKey:kFavoritesDefaultsKey];
    [self.favoriteIDs removeAllObjects];

    if (![stored isKindOfClass:NSArray.class]) {
        return;
    }

    for (id value in stored) {
        if ([value isKindOfClass:NSString.class] && ((NSString *)value).length > 0) {
            [self.favoriteIDs addObject:value];
        }
    }

    [self normalizeFavoriteTrackIDsIfNeeded];
}

- (void)persistFavorites {
    [NSUserDefaults.standardUserDefaults setObject:self.favoriteIDs.array ?: @[] forKey:kFavoritesDefaultsKey];
}

@end

#pragma mark - Track Analytics

@interface M2TrackAnalyticsStore ()
@end

@implementation M2TrackAnalyticsStore

+ (instancetype)sharedStore {
    static M2TrackAnalyticsStore *store;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        store = [[M2TrackAnalyticsStore alloc] init];
    });
    return store;
}

- (nullable NSManagedObjectContext *)analyticsContext {
    id<UIApplicationDelegate> appDelegate = UIApplication.sharedApplication.delegate;
    if (![appDelegate isKindOfClass:AppDelegate.class]) {
        return nil;
    }

    AppDelegate *typedDelegate = (AppDelegate *)appDelegate;
    return typedDelegate.persistentContainer.viewContext;
}

- (nullable NSManagedObject *)entryForTrackID:(NSString *)trackID
                                    inContext:(NSManagedObjectContext *)context
                                 createIfMiss:(BOOL)createIfMiss {
    if (trackID.length == 0 || context == nil) {
        return nil;
    }

    NSFetchRequest<NSManagedObject *> *request = [NSFetchRequest fetchRequestWithEntityName:kTrackAnalyticsEntityName];
    request.predicate = [NSPredicate predicateWithFormat:@"%K == %@", kTrackAnalyticsTrackIDKey, trackID];
    request.fetchLimit = 1;

    NSError *fetchError = nil;
    NSArray<NSManagedObject *> *results = [context executeFetchRequest:request error:&fetchError];
    if (results.count > 0) {
        return results.firstObject;
    }

    if (!createIfMiss) {
        return nil;
    }

    NSEntityDescription *entity = [NSEntityDescription entityForName:kTrackAnalyticsEntityName inManagedObjectContext:context];
    if (entity == nil) {
        return nil;
    }

    NSManagedObject *entry = [[NSManagedObject alloc] initWithEntity:entity insertIntoManagedObjectContext:context];
    [entry setValue:trackID forKey:kTrackAnalyticsTrackIDKey];
    [entry setValue:@(0) forKey:kTrackAnalyticsPlayCountKey];
    [entry setValue:@(0) forKey:kTrackAnalyticsSkipCountKey];
    [entry setValue:NSDate.date forKey:kTrackAnalyticsUpdatedAtKey];
    return entry;
}

- (void)saveContextIfNeeded:(NSManagedObjectContext *)context {
    if (context == nil || !context.hasChanges) {
        return;
    }

    NSError *saveError = nil;
    [context save:&saveError];
    if (saveError != nil) {
        NSLog(@"Track analytics save error: %@", saveError.localizedDescription);
    }
}

- (void)recordPlayForTrackID:(NSString *)trackID {
    NSManagedObjectContext *context = [self analyticsContext];
    if (context == nil || trackID.length == 0) {
        return;
    }

    [context performBlockAndWait:^{
        NSManagedObject *entry = [self entryForTrackID:trackID inContext:context createIfMiss:YES];
        if (entry == nil) {
            return;
        }

        NSInteger playCount = [[entry valueForKey:kTrackAnalyticsPlayCountKey] integerValue];
        [entry setValue:@(playCount + 1) forKey:kTrackAnalyticsPlayCountKey];
        [entry setValue:NSDate.date forKey:kTrackAnalyticsUpdatedAtKey];
        [self saveContextIfNeeded:context];
    }];
}

- (void)recordSkipForTrackID:(NSString *)trackID {
    NSManagedObjectContext *context = [self analyticsContext];
    if (context == nil || trackID.length == 0) {
        return;
    }

    [context performBlockAndWait:^{
        NSManagedObject *entry = [self entryForTrackID:trackID inContext:context createIfMiss:YES];
        if (entry == nil) {
            return;
        }

        NSInteger skipCount = [[entry valueForKey:kTrackAnalyticsSkipCountKey] integerValue];
        [entry setValue:@(skipCount + 1) forKey:kTrackAnalyticsSkipCountKey];
        [entry setValue:NSDate.date forKey:kTrackAnalyticsUpdatedAtKey];
        [self saveContextIfNeeded:context];
    }];
}

- (double)scoreForTrackID:(NSString *)trackID {
    if (trackID.length == 0) {
        return 0.0;
    }

    NSManagedObjectContext *context = [self analyticsContext];
    if (context == nil) {
        return 0.0;
    }

    __block double score = 0.0;
    [context performBlockAndWait:^{
        NSManagedObject *entry = [self entryForTrackID:trackID inContext:context createIfMiss:NO];
        if (entry == nil) {
            score = 0.0;
            return;
        }

        double plays = [[entry valueForKey:kTrackAnalyticsPlayCountKey] doubleValue];
        double skips = [[entry valueForKey:kTrackAnalyticsSkipCountKey] doubleValue];
        score = plays / (plays + skips + 1.0);
    }];
    return score;
}

- (NSDictionary<NSString *, NSDictionary<NSString *, NSNumber *> *> *)analyticsByTrackIDForTrackIDs:(NSArray<NSString *> *)trackIDs {
    if (trackIDs.count == 0) {
        return @{};
    }

    NSManagedObjectContext *context = [self analyticsContext];
    if (context == nil) {
        return @{};
    }

    NSMutableArray<NSString *> *normalized = [NSMutableArray arrayWithCapacity:trackIDs.count];
    for (NSString *trackID in trackIDs) {
        if ([trackID isKindOfClass:NSString.class] && trackID.length > 0) {
            [normalized addObject:trackID];
        }
    }
    if (normalized.count == 0) {
        return @{};
    }

    __block NSDictionary<NSString *, NSDictionary<NSString *, NSNumber *> *> *result = @{};
    [context performBlockAndWait:^{
        NSFetchRequest<NSManagedObject *> *request = [NSFetchRequest fetchRequestWithEntityName:kTrackAnalyticsEntityName];
        request.predicate = [NSPredicate predicateWithFormat:@"%K IN %@", kTrackAnalyticsTrackIDKey, normalized];

        NSError *fetchError = nil;
        NSArray<NSManagedObject *> *entries = [context executeFetchRequest:request error:&fetchError];
        if (fetchError != nil || entries.count == 0) {
            result = @{};
            return;
        }

        NSMutableDictionary<NSString *, NSDictionary<NSString *, NSNumber *> *> *map = [NSMutableDictionary dictionaryWithCapacity:entries.count];
        for (NSManagedObject *entry in entries) {
            NSString *trackID = [entry valueForKey:kTrackAnalyticsTrackIDKey];
            if (![trackID isKindOfClass:NSString.class] || trackID.length == 0) {
                continue;
            }

            NSInteger playCount = [[entry valueForKey:kTrackAnalyticsPlayCountKey] integerValue];
            NSInteger skipCount = [[entry valueForKey:kTrackAnalyticsSkipCountKey] integerValue];
            double score = ((double)playCount) / ((double)playCount + (double)skipCount + 1.0);

            map[trackID] = @{
                @"playCount": @(playCount),
                @"skipCount": @(skipCount),
                @"score": @(score)
            };
        }

        result = [map copy];
    }];
    return result;
}

- (NSDictionary<NSString *, NSNumber *> *)scoreMapForTrackIDs:(NSArray<NSString *> *)trackIDs {
    if (trackIDs.count == 0) {
        return @{};
    }

    NSManagedObjectContext *context = [self analyticsContext];
    if (context == nil) {
        return @{};
    }

    NSMutableArray<NSString *> *normalized = [NSMutableArray arrayWithCapacity:trackIDs.count];
    for (NSString *trackID in trackIDs) {
        if ([trackID isKindOfClass:NSString.class] && trackID.length > 0) {
            [normalized addObject:trackID];
        }
    }
    if (normalized.count == 0) {
        return @{};
    }

    __block NSDictionary<NSString *, NSNumber *> *result = @{};
    [context performBlockAndWait:^{
        NSFetchRequest<NSManagedObject *> *request = [NSFetchRequest fetchRequestWithEntityName:kTrackAnalyticsEntityName];
        request.predicate = [NSPredicate predicateWithFormat:@"%K IN %@", kTrackAnalyticsTrackIDKey, normalized];

        NSError *error = nil;
        NSArray<NSManagedObject *> *entries = [context executeFetchRequest:request error:&error];
        if (entries.count == 0 || error != nil) {
            result = @{};
            return;
        }

        NSMutableDictionary<NSString *, NSNumber *> *map = [NSMutableDictionary dictionaryWithCapacity:entries.count];
        for (NSManagedObject *entry in entries) {
            NSString *trackID = [entry valueForKey:kTrackAnalyticsTrackIDKey];
            if (![trackID isKindOfClass:NSString.class] || trackID.length == 0) {
                continue;
            }

            double plays = [[entry valueForKey:kTrackAnalyticsPlayCountKey] doubleValue];
            double skips = [[entry valueForKey:kTrackAnalyticsSkipCountKey] doubleValue];
            double score = plays / (plays + skips + 1.0);
            map[trackID] = @(score);
        }
        result = [map copy];
    }];
    return result;
}

- (NSArray<M2Track *> *)tracksSortedByAffinity:(NSArray<M2Track *> *)tracks {
    if (tracks.count <= 1) {
        return tracks ?: @[];
    }

    NSMutableArray<NSString *> *trackIDs = [NSMutableArray arrayWithCapacity:tracks.count];
    for (M2Track *track in tracks) {
        if (track.identifier.length > 0) {
            [trackIDs addObject:track.identifier];
        }
    }

    NSDictionary<NSString *, NSNumber *> *scoreByID = [self scoreMapForTrackIDs:trackIDs];
    return [tracks sortedArrayUsingComparator:^NSComparisonResult(M2Track * _Nonnull left, M2Track * _Nonnull right) {
        double leftScore = [scoreByID[left.identifier] doubleValue];
        double rightScore = [scoreByID[right.identifier] doubleValue];
        if (leftScore > rightScore) {
            return NSOrderedAscending;
        }
        if (leftScore < rightScore) {
            return NSOrderedDescending;
        }
        return [left.title localizedCaseInsensitiveCompare:right.title];
    }];
}

@end

#pragma mark - Playback

@interface M2PlaybackManager () <AVAudioPlayerDelegate>

@property (nonatomic, strong, nullable) AVAudioPlayer *audioPlayer;
@property (nonatomic, copy) NSArray<M2Track *> *queue;
@property (nonatomic, assign) NSInteger currentIndex;
@property (nonatomic, strong, nullable) NSTimer *progressTimer;
@property (nonatomic, assign) M2RepeatMode repeatMode;
@property (nonatomic, assign, getter=isShuffleEnabled) BOOL shuffleEnabled;
@property (nonatomic, strong) NSMutableArray<NSNumber *> *shuffleBag;
@property (nonatomic, strong) NSMutableArray<NSNumber *> *shuffleHistory;
@property (nonatomic, copy) NSString *analyticsTrackID;
@property (nonatomic, assign) NSTimeInterval analyticsTrackDuration;
@property (nonatomic, assign) NSTimeInterval analyticsMaxProgressTime;
@property (nonatomic, assign) BOOL analyticsDidSeekNearEnd;

@end

@implementation M2PlaybackManager

+ (instancetype)sharedManager {
    static M2PlaybackManager *manager;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        manager = [[M2PlaybackManager alloc] init];
    });
    return manager;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        _queue = @[];
        _currentIndex = NSNotFound;
        _repeatMode = M2RepeatModeNone;
        _shuffleEnabled = NO;
        _shuffleBag = [NSMutableArray array];
        _shuffleHistory = [NSMutableArray array];
        _analyticsTrackID = @"";
        _analyticsTrackDuration = 0.0;
        _analyticsMaxProgressTime = 0.0;
        _analyticsDidSeekNearEnd = NO;
        [self configureRemoteCommands];
        [self updateRemoteCommandAvailability];
    }
    return self;
}

- (nullable M2Track *)currentTrack {
    if (self.currentIndex == NSNotFound || self.currentIndex >= self.queue.count) {
        return nil;
    }
    return self.queue[self.currentIndex];
}

- (BOOL)isPlaying {
    return self.audioPlayer.isPlaying;
}

- (NSTimeInterval)currentTime {
    return self.audioPlayer != nil ? self.audioPlayer.currentTime : 0.0;
}

- (NSTimeInterval)duration {
    if (self.audioPlayer != nil) {
        return self.audioPlayer.duration;
    }
    M2Track *track = self.currentTrack;
    return track != nil ? track.duration : 0.0;
}

- (NSArray<M2Track *> *)currentQueue {
    return self.queue;
}

- (void)resetAnalyticsSession {
    self.analyticsTrackID = @"";
    self.analyticsTrackDuration = 0.0;
    self.analyticsMaxProgressTime = 0.0;
    self.analyticsDidSeekNearEnd = NO;
}

- (void)beginAnalyticsSessionForCurrentTrack {
    M2Track *track = self.currentTrack;
    if (track.identifier.length == 0) {
        [self resetAnalyticsSession];
        return;
    }

    self.analyticsTrackID = track.identifier;
    NSTimeInterval duration = self.audioPlayer != nil ? self.audioPlayer.duration : track.duration;
    if (!isfinite(duration) || duration <= 0.0) {
        duration = track.duration;
    }
    self.analyticsTrackDuration = MAX(0.0, duration);
    self.analyticsMaxProgressTime = MAX(0.0, self.audioPlayer.currentTime);
    self.analyticsDidSeekNearEnd = NO;
}

- (void)updateAnalyticsProgressSnapshot {
    if (self.analyticsTrackID.length == 0) {
        return;
    }

    NSTimeInterval currentTime = self.audioPlayer != nil ? self.audioPlayer.currentTime : 0.0;
    if (isfinite(currentTime) && currentTime > self.analyticsMaxProgressTime) {
        self.analyticsMaxProgressTime = currentTime;
    }
}

- (void)markSeekForAnalyticsToTime:(NSTimeInterval)targetTime {
    if (self.analyticsTrackID.length == 0) {
        return;
    }

    NSTimeInterval duration = self.analyticsTrackDuration;
    if ((!isfinite(duration) || duration <= 0.0) && self.audioPlayer != nil) {
        duration = self.audioPlayer.duration;
    }
    if (!isfinite(duration) || duration <= 0.0) {
        return;
    }

    double currentRatio = self.analyticsMaxProgressTime / duration;
    double targetRatio = targetTime / duration;
    if (targetRatio >= 0.92 && currentRatio < 0.80) {
        self.analyticsDidSeekNearEnd = YES;
    }
}

- (void)finalizeAnalyticsForCurrentTrackFinished:(BOOL)finishedNaturally
                                 countSkipIfEarly:(BOOL)countSkipIfEarly {
    if (self.analyticsTrackID.length == 0) {
        return;
    }

    [self updateAnalyticsProgressSnapshot];

    NSTimeInterval duration = self.analyticsTrackDuration;
    if ((!isfinite(duration) || duration <= 0.0) && self.audioPlayer != nil) {
        duration = self.audioPlayer.duration;
    }
    if (!isfinite(duration) || duration <= 0.0) {
        [self resetAnalyticsSession];
        return;
    }

    double listenedRatio = MAX(0.0, MIN(self.analyticsMaxProgressTime / duration, 1.0));
    BOOL shouldCountPlay = (!self.analyticsDidSeekNearEnd) && (finishedNaturally || listenedRatio >= 0.80);
    BOOL shouldCountSkip = countSkipIfEarly && (listenedRatio < 0.20);

    if (shouldCountPlay) {
        [M2TrackAnalyticsStore.sharedStore recordPlayForTrackID:self.analyticsTrackID];
    }
    if (shouldCountSkip) {
        [M2TrackAnalyticsStore.sharedStore recordSkipForTrackID:self.analyticsTrackID];
    }

    [self resetAnalyticsSession];
}

- (void)playTrack:(M2Track *)track {
    if (track == nil) {
        return;
    }
    [self playTracks:@[track] startIndex:0];
}

- (void)playTracks:(NSArray<M2Track *> *)tracks startIndex:(NSInteger)index {
    if (tracks.count == 0) {
        return;
    }

    NSInteger normalizedIndex = index;
    if (normalizedIndex < 0 || normalizedIndex >= tracks.count) {
        normalizedIndex = 0;
    }

    [self resetAnalyticsSession];
    self.queue = [tracks copy];
    self.currentIndex = normalizedIndex;

    [self.shuffleBag removeAllObjects];
    [self.shuffleHistory removeAllObjects];
    [self rebuildShuffleBagIfNeeded];
    [self updateRemoteCommandAvailability];

    [self startCurrentTrack];
}

- (void)togglePlayPause {
    if (self.queue.count == 0) {
        return;
    }

    if (self.audioPlayer == nil) {
        if (self.currentIndex == NSNotFound) {
            self.currentIndex = 0;
        }
        [self startCurrentTrack];
        return;
    }

    if (self.audioPlayer.isPlaying) {
        [self.audioPlayer pause];
        [self.progressTimer invalidate];
        self.progressTimer = nil;
    } else {
        [self.audioPlayer play];
        [self startProgressTimerIfNeeded];
    }

    [self updateNowPlayingInfo];
    [self postStateDidChange];
    [self postProgressDidChange];
}

- (void)playNext {
    [self advanceToNextTrackAutomatically:NO];
}

- (void)playPrevious {
    if (self.queue.count == 0) {
        return;
    }

    if (self.audioPlayer != nil && self.audioPlayer.currentTime > 3.0) {
        [self seekToTime:0.0];
        return;
    }

    if (self.isShuffleEnabled) {
        if (self.shuffleHistory.count > 0) {
            NSInteger previousIndex = self.shuffleHistory.lastObject.integerValue;
            [self.shuffleHistory removeLastObject];
            [self finalizeAnalyticsForCurrentTrackFinished:NO countSkipIfEarly:YES];
            self.currentIndex = previousIndex;
            [self startCurrentTrack];
            return;
        }

        NSInteger randomIndex = [self randomIndexExcluding:self.currentIndex];
        if (randomIndex != NSNotFound) {
            [self finalizeAnalyticsForCurrentTrackFinished:NO countSkipIfEarly:YES];
            self.currentIndex = randomIndex;
            [self rebuildShuffleBagIfNeeded];
            [self startCurrentTrack];
            return;
        }

        [self restartCurrentTrack];
        return;
    }

    if (self.currentIndex == NSNotFound) {
        self.currentIndex = 0;
        [self startCurrentTrack];
        return;
    }

    NSInteger previous = self.currentIndex - 1;
    if (previous < 0) {
        if (self.repeatMode == M2RepeatModeQueue) {
            previous = self.queue.count - 1;
        } else {
            [self restartCurrentTrack];
            return;
        }
    }

    [self finalizeAnalyticsForCurrentTrackFinished:NO countSkipIfEarly:YES];
    self.currentIndex = previous;
    [self startCurrentTrack];
}

- (void)seekToTime:(NSTimeInterval)time {
    if (self.audioPlayer == nil) {
        return;
    }

    [self updateAnalyticsProgressSnapshot];
    NSTimeInterval clamped = MAX(0.0, MIN(time, self.audioPlayer.duration));
    [self markSeekForAnalyticsToTime:clamped];
    self.audioPlayer.currentTime = clamped;

    [self updateNowPlayingInfo];
    [self postProgressDidChange];
}

- (void)setShuffleEnabled:(BOOL)enabled {
    if (_shuffleEnabled == enabled) {
        return;
    }

    _shuffleEnabled = enabled;
    [self.shuffleHistory removeAllObjects];
    [self rebuildShuffleBagIfNeeded];
    [self updateRemoteCommandAvailability];
    [self postStateDidChange];
}

- (void)toggleShuffleEnabled {
    [self setShuffleEnabled:!self.isShuffleEnabled];
}

- (M2RepeatMode)cycleRepeatMode {
    switch (self.repeatMode) {
        case M2RepeatModeNone:
            self.repeatMode = M2RepeatModeQueue;
            break;
        case M2RepeatModeQueue:
            self.repeatMode = M2RepeatModeTrack;
            break;
        case M2RepeatModeTrack:
            self.repeatMode = M2RepeatModeNone;
            break;
    }

    [self updateRemoteCommandAvailability];
    [self postStateDidChange];
    return self.repeatMode;
}

- (nullable M2Track *)predictedNextTrackForSkip {
    if (self.queue.count == 0) {
        return nil;
    }

    if (self.isShuffleEnabled) {
        if (self.queue.count == 1) {
            return self.queue.firstObject;
        }

        if (self.shuffleBag.count == 0) {
            if (self.repeatMode == M2RepeatModeNone) {
                return nil;
            }
            [self rebuildShuffleBagIfNeeded];
        }

        if (self.shuffleBag.count == 0) {
            return nil;
        }

        NSInteger nextIndex = self.shuffleBag.firstObject.integerValue;
        if (nextIndex < 0 || nextIndex >= self.queue.count) {
            return nil;
        }
        return self.queue[nextIndex];
    }

    NSInteger nextIndex = (self.currentIndex == NSNotFound) ? 0 : self.currentIndex + 1;
    if (nextIndex >= self.queue.count) {
        if (self.repeatMode == M2RepeatModeQueue) {
            nextIndex = 0;
        } else {
            return nil;
        }
    }

    return self.queue[nextIndex];
}

- (void)advanceToNextTrackAutomatically:(BOOL)automatic {
    if (self.queue.count == 0) {
        return;
    }

    if (automatic && self.repeatMode == M2RepeatModeTrack) {
        [self finalizeAnalyticsForCurrentTrackFinished:YES countSkipIfEarly:NO];
        [self restartCurrentTrack];
        return;
    }

    NSInteger previousIndex = self.currentIndex;
    NSInteger nextIndex = [self nextIndexForAdvanceAutomatic:automatic];

    if (nextIndex == NSNotFound) {
        if (automatic) {
            [self finalizeAnalyticsForCurrentTrackFinished:YES countSkipIfEarly:NO];
            [self stopPlaybackAtQueueEnd];
        }
        return;
    }

    if (self.isShuffleEnabled && previousIndex != NSNotFound && previousIndex != nextIndex) {
        [self.shuffleHistory addObject:@(previousIndex)];
    }

    [self finalizeAnalyticsForCurrentTrackFinished:automatic countSkipIfEarly:!automatic];
    self.currentIndex = nextIndex;
    [self startCurrentTrack];
}

- (NSInteger)nextIndexForAdvanceAutomatic:(BOOL)automatic {
    if (self.queue.count == 0) {
        return NSNotFound;
    }

    if (self.isShuffleEnabled) {
        if (self.queue.count == 1) {
            if (automatic && self.repeatMode == M2RepeatModeNone) {
                return NSNotFound;
            }
            return 0;
        }

        if (self.shuffleBag.count == 0) {
            if (self.repeatMode == M2RepeatModeNone) {
                return NSNotFound;
            }
            [self rebuildShuffleBagIfNeeded];
        }

        if (self.shuffleBag.count == 0) {
            return NSNotFound;
        }

        NSInteger next = self.shuffleBag.firstObject.integerValue;
        [self.shuffleBag removeObjectAtIndex:0];
        return next;
    }

    NSInteger next = (self.currentIndex == NSNotFound) ? 0 : self.currentIndex + 1;
    if (next < self.queue.count) {
        return next;
    }

    if (self.repeatMode == M2RepeatModeQueue) {
        return 0;
    }

    return NSNotFound;
}

- (void)restartCurrentTrack {
    if (self.queue.count == 0) {
        return;
    }

    if (self.currentIndex == NSNotFound) {
        self.currentIndex = 0;
    }

    if (self.audioPlayer != nil) {
        self.audioPlayer.currentTime = 0.0;
        [self.audioPlayer play];
        [self startProgressTimerIfNeeded];
        [self updateNowPlayingInfo];
        [self postStateDidChange];
        [self postProgressDidChange];
        return;
    }

    [self startCurrentTrack];
}

- (void)stopPlaybackAtQueueEnd {
    [self.progressTimer invalidate];
    self.progressTimer = nil;

    [self.audioPlayer stop];
    self.audioPlayer = nil;
    [self resetAnalyticsSession];

    [self updateRemoteCommandAvailability];
    [self updateNowPlayingInfo];
    [self postStateDidChange];
    [self postProgressDidChange];
}

- (void)rebuildShuffleBagIfNeeded {
    [self.shuffleBag removeAllObjects];

    if (!self.isShuffleEnabled || self.queue.count <= 1) {
        return;
    }

    for (NSInteger index = 0; index < self.queue.count; index += 1) {
        if (index != self.currentIndex) {
            [self.shuffleBag addObject:@(index)];
        }
    }

    for (NSInteger i = self.shuffleBag.count - 1; i > 0; i -= 1) {
        u_int32_t j = arc4random_uniform((u_int32_t)(i + 1));
        [self.shuffleBag exchangeObjectAtIndex:i withObjectAtIndex:j];
    }
}

- (NSInteger)randomIndexExcluding:(NSInteger)excludedIndex {
    if (self.queue.count == 0) {
        return NSNotFound;
    }

    if (self.queue.count == 1) {
        return 0;
    }

    NSInteger randomIndex = excludedIndex;
    NSInteger guard = 0;
    while (randomIndex == excludedIndex && guard < 16) {
        randomIndex = (NSInteger)arc4random_uniform((u_int32_t)self.queue.count);
        guard += 1;
    }

    return randomIndex;
}

- (void)startCurrentTrack {
    if (self.currentIndex == NSNotFound && self.queue.count > 0) {
        self.currentIndex = 0;
    }

    M2Track *track = self.currentTrack;
    if (track == nil) {
        [self resetAnalyticsSession];
        [self updateRemoteCommandAvailability];
        return;
    }

    [self.audioPlayer stop];
    self.audioPlayer = nil;

    NSError *playerError = nil;
    AVAudioPlayer *player = [[AVAudioPlayer alloc] initWithContentsOfURL:track.url error:&playerError];
    if (player == nil || playerError != nil) {
        NSLog(@"Playback init failed: %@", playerError.localizedDescription);
        [self.progressTimer invalidate];
        self.progressTimer = nil;
        [self resetAnalyticsSession];
        [self updateRemoteCommandAvailability];
        [self postStateDidChange];
        return;
    }

    player.delegate = self;
    [player prepareToPlay];

    if (![player play]) {
        NSLog(@"Playback start failed for %@", track.fileName);
        [self.progressTimer invalidate];
        self.progressTimer = nil;
        [self resetAnalyticsSession];
        [self updateRemoteCommandAvailability];
        [self postStateDidChange];
        return;
    }

    self.audioPlayer = player;
    [self beginAnalyticsSessionForCurrentTrack];

    [self startProgressTimerIfNeeded];
    [self updateNowPlayingInfo];
    [self postStateDidChange];
    [self postProgressDidChange];
}

- (void)startProgressTimerIfNeeded {
    [self.progressTimer invalidate];
    self.progressTimer = [NSTimer scheduledTimerWithTimeInterval:0.4
                                                          target:self
                                                        selector:@selector(handleProgressTick)
                                                        userInfo:nil
                                                         repeats:YES];
}

- (void)handleProgressTick {
    if (self.audioPlayer == nil) {
        return;
    }

    [self updateAnalyticsProgressSnapshot];
    [self updateNowPlayingInfo];
    [self postProgressDidChange];
}

- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag {
    (void)player;
    (void)flag;
    [self advanceToNextTrackAutomatically:YES];
}

- (void)configureRemoteCommands {
    MPRemoteCommandCenter *center = MPRemoteCommandCenter.sharedCommandCenter;

    [center.playCommand addTarget:self action:@selector(handleRemotePlay:)];
    [center.pauseCommand addTarget:self action:@selector(handleRemotePause:)];
    [center.togglePlayPauseCommand addTarget:self action:@selector(handleRemoteToggle:)];
    [center.nextTrackCommand addTarget:self action:@selector(handleRemoteNext:)];
    [center.previousTrackCommand addTarget:self action:@selector(handleRemotePrevious:)];
    if (@available(iOS 9.1, *)) {
        [center.changePlaybackPositionCommand addTarget:self action:@selector(handleRemoteChangePlaybackPosition:)];
    }
    [self updateRemoteCommandAvailability];
}

- (MPRemoteCommandHandlerStatus)handleRemotePlay:(MPRemoteCommandEvent *)event {
    (void)event;

    if (self.audioPlayer != nil && !self.audioPlayer.isPlaying) {
        [self togglePlayPause];
        return MPRemoteCommandHandlerStatusSuccess;
    }

    if (self.audioPlayer != nil) {
        return MPRemoteCommandHandlerStatusSuccess;
    }

    if (self.queue.count == 0) {
        return MPRemoteCommandHandlerStatusNoSuchContent;
    }

    if (self.currentIndex == NSNotFound) {
        self.currentIndex = 0;
    }

    [self startCurrentTrack];
    return MPRemoteCommandHandlerStatusSuccess;
}

- (MPRemoteCommandHandlerStatus)handleRemotePause:(MPRemoteCommandEvent *)event {
    (void)event;

    if (self.audioPlayer == nil || !self.audioPlayer.isPlaying) {
        return MPRemoteCommandHandlerStatusCommandFailed;
    }

    [self togglePlayPause];
    return MPRemoteCommandHandlerStatusSuccess;
}

- (MPRemoteCommandHandlerStatus)handleRemoteToggle:(MPRemoteCommandEvent *)event {
    (void)event;
    [self togglePlayPause];
    return MPRemoteCommandHandlerStatusSuccess;
}

- (MPRemoteCommandHandlerStatus)handleRemoteNext:(MPRemoteCommandEvent *)event {
    (void)event;
    [self playNext];
    return MPRemoteCommandHandlerStatusSuccess;
}

- (MPRemoteCommandHandlerStatus)handleRemotePrevious:(MPRemoteCommandEvent *)event {
    (void)event;
    [self playPrevious];
    return MPRemoteCommandHandlerStatusSuccess;
}

- (MPRemoteCommandHandlerStatus)handleRemoteChangePlaybackPosition:(MPRemoteCommandEvent *)event {
    if (self.audioPlayer == nil || self.duration <= 0.0) {
        return MPRemoteCommandHandlerStatusCommandFailed;
    }

    if (![event isKindOfClass:MPChangePlaybackPositionCommandEvent.class]) {
        return MPRemoteCommandHandlerStatusCommandFailed;
    }

    MPChangePlaybackPositionCommandEvent *positionEvent = (MPChangePlaybackPositionCommandEvent *)event;
    [self seekToTime:positionEvent.positionTime];
    return MPRemoteCommandHandlerStatusSuccess;
}

- (void)updateNowPlayingInfo {
    M2Track *track = self.currentTrack;
    if (track == nil || self.audioPlayer == nil) {
        MPNowPlayingInfoCenter.defaultCenter.nowPlayingInfo = nil;
        return;
    }

    NSMutableDictionary<NSString *, id> *info = [NSMutableDictionary dictionary];
    info[MPMediaItemPropertyTitle] = track.title ?: @"Unknown Track";
    if (track.artist.length > 0) {
        info[MPMediaItemPropertyArtist] = track.artist;
    }
    info[MPMediaItemPropertyPlaybackDuration] = @(self.audioPlayer.duration);
    info[MPNowPlayingInfoPropertyElapsedPlaybackTime] = @(self.audioPlayer.currentTime);
    info[MPNowPlayingInfoPropertyPlaybackRate] = self.audioPlayer.isPlaying ? @1.0 : @0.0;
    NSInteger queueCount = (NSInteger)self.queue.count;
    NSInteger queueIndex = self.currentIndex;
    if (queueCount > 0) {
        if (queueIndex == NSNotFound) {
            queueIndex = 0;
        }
        queueIndex = MIN(MAX(queueIndex, 0), queueCount - 1);
        info[MPNowPlayingInfoPropertyPlaybackQueueCount] = @(queueCount);
        info[MPNowPlayingInfoPropertyPlaybackQueueIndex] = @(queueIndex);
    }

    if (track.artwork != nil) {
        MPMediaItemArtwork *artwork = [[MPMediaItemArtwork alloc] initWithBoundsSize:track.artwork.size
                                                                       requestHandler:^UIImage * _Nonnull(CGSize size) {
            (void)size;
            return track.artwork;
        }];
        info[MPMediaItemPropertyArtwork] = artwork;
    }

    MPNowPlayingInfoCenter.defaultCenter.nowPlayingInfo = info;
}

- (void)updateRemoteCommandAvailability {
    MPRemoteCommandCenter *center = MPRemoteCommandCenter.sharedCommandCenter;
    BOOL hasQueue = (self.queue.count > 0);
    BOOL canStep = (self.queue.count > 1) || self.isShuffleEnabled || (self.repeatMode != M2RepeatModeNone);
    BOOL canSeek = (self.audioPlayer != nil && self.audioPlayer.duration > 0.0);

    center.playCommand.enabled = hasQueue;
    center.pauseCommand.enabled = hasQueue;
    center.togglePlayPauseCommand.enabled = hasQueue;
    center.nextTrackCommand.enabled = hasQueue && canStep;
    center.previousTrackCommand.enabled = hasQueue && canStep;
    if (@available(iOS 9.1, *)) {
        center.changePlaybackPositionCommand.enabled = hasQueue && canSeek;
    }
}

- (void)postStateDidChange {
    [self updateRemoteCommandAvailability];
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaybackStateDidChangeNotification object:self];
}

- (void)postProgressDidChange {
    [NSNotificationCenter.defaultCenter postNotificationName:M2PlaybackProgressDidChangeNotification object:self];
}

@end

#pragma mark - Sleep Timer

@interface M2SleepTimerManager ()

@property (nonatomic, strong, nullable) NSDate *fireDate;
@property (nonatomic, strong, nullable) dispatch_source_t timer;

@end

@implementation M2SleepTimerManager

+ (instancetype)sharedManager {
    static M2SleepTimerManager *manager;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        manager = [[M2SleepTimerManager alloc] init];
    });
    return manager;
}

- (BOOL)isActive {
    return self.remainingTime > 0.0;
}

- (NSTimeInterval)remainingTime {
    if (self.fireDate == nil) {
        return 0.0;
    }

    NSTimeInterval remaining = [self.fireDate timeIntervalSinceNow];
    if (!isfinite(remaining) || remaining <= 0.0) {
        return 0.0;
    }
    return remaining;
}

- (void)startWithDuration:(NSTimeInterval)duration {
    NSTimeInterval normalizedDuration = MAX(duration, 0.0);
    if (normalizedDuration <= 0.0) {
        [self cancel];
        return;
    }

    [self invalidateTimer];
    self.fireDate = [NSDate dateWithTimeIntervalSinceNow:normalizedDuration];

    __weak typeof(self) weakSelf = self;
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());
    dispatch_source_set_event_handler(timer, ^{
        __strong typeof(weakSelf) strongSelf = weakSelf;
        if (strongSelf == nil) {
            return;
        }
        [strongSelf handleTimerFired];
    });
    dispatch_source_set_timer(timer,
                              dispatch_time(DISPATCH_TIME_NOW, (int64_t)(normalizedDuration * (NSTimeInterval)NSEC_PER_SEC)),
                              DISPATCH_TIME_FOREVER,
                              (uint64_t)(0.1 * (NSTimeInterval)NSEC_PER_SEC));
    self.timer = timer;
    dispatch_resume(timer);

    M2SyncSleepLiveActivity(normalizedDuration);
    [self postDidChange];
}

- (void)cancel {
    if (self.fireDate == nil && self.timer == nil) {
        return;
    }

    [self invalidateTimer];
    self.fireDate = nil;
    M2EndSleepLiveActivity();
    [self postDidChange];
}

- (void)handleTimerFired {
    [self invalidateTimer];
    self.fireDate = nil;

    M2PlaybackManager *playback = M2PlaybackManager.sharedManager;
    if (playback.isPlaying) {
        [playback togglePlayPause];
    }

    M2EndSleepLiveActivity();
    [self postDidChange];
}

- (void)invalidateTimer {
    if (self.timer == nil) {
        return;
    }

    dispatch_source_cancel(self.timer);
    self.timer = nil;
}

- (void)postDidChange {
    [NSNotificationCenter.defaultCenter postNotificationName:M2SleepTimerDidChangeNotification object:self];
}

@end
